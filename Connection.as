package {	import fl.motion.Color;	import flash.display.MovieClip;	import flash.geom.Vector3D;	public class Connection	{		// two points involved: p and q		// spring between them has weight k and rest length l		private var p:PointMass;		private var q:PointMass;		private var k:Number;		private var l:Number;		public function Connection(point1:PointMass,point2:PointMass, idealLength:Number = 0, weight:Number = 0.01)		{			p = point1;			q = point2;			l = idealLength;			k = weight;		}				public function spring():void {		    // add forces to each point. does not flush (and should not until		    //  all connections have been `spring()`ed)					// <dx, dy> is vector from p to q;			var dx = q.pos.x - p.pos.x;			var dy = q.pos.y - p.pos.y;			// But, we need to account for 'rest length' being `l` not 0			// Normalize dx and dy to length 1; purely directional. `_n` means 'normalized' here			var dist = Math.sqrt(dx*dx + dy*dy);			var dx_n = dx / dist;			var dy_n = dy / dist;			// Subtract `l` from dist between points from. this is the true offset			//  (think of it as 'zero'd on `l`'			var true_offset = (dist - l);			// scale the normalized dx and dy by the true offset. use these to			//  calculate spring forces.			dx_n *= true_offset;			dy_n *= true_offset;			// force in x and y from Hooke's Law (force = -k * displacement)			//  note that forces on p and q are equal and opposite, and that			//  because <dx, dy> points *from* p *to* q, positive displacement			//  restores q towards p and p towards q			var fx = k*dx_n;			var fy = k*dy_n;			p.addForce(new Vector3D(+fx, +fy));			q.addForce(new Vector3D(-fx, -fy));		}				public function getPoints():Array {			return new Array(p,q);		}		public function disp(dispClip:MovieClip, dispPoints:Boolean = false, color:uint = 0x000000):void		{			// draw line between points of weight 1			var line_weight:Number = 1;			dispClip.graphics.lineStyle(color, line_weight);			dispClip.graphics.moveTo(p.pos.x,p.pos.y);			dispClip.graphics.lineTo(q.pos.x,q.pos.y);			if(dispPoints) {				dispClip.graphics.beginFill(color);				dispClip.graphics.drawCircle(p.pos.x,p.pos.y,Math.sqrt(p.mass));				dispClip.graphics.drawCircle(q.pos.x,q.pos.y,Math.sqrt(q.mass));				dispClip.graphics.endFill();			}		}	}}