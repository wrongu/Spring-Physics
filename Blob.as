package {	import flash.geom.Point;	import flash.display.MovieClip;	public class Blob extends System	{		// constructor can make different 'types' of blob.		//currently only 1 type available..		public function Blob(center:Point, divisions:Number = 18, radius:Number = 40, type:Number = 0)		{			// this `type` switch is so that other blob geometries can be added in the future. the assumption is that all			// will have some center hub point.			switch (type)			{				case 0 :					// TYPE 0:					// -all points have mass 1					// -a hub with a single spoke to each outer point					// -a connection between each outer point and it's immediate neighbor					// -a connection between each outer point and the outer pt. TWO away (prevents skin from folding over itself)					// -for each point, a connection across the whole blob to the point directly across**					// **NOTE: this means only EVEN divisions allowed:					if (divisions % 2 != 0)					{						divisions++;					}// set up central hub at given start point:					var hub:PointMass = new PointMass(1,center);					// radian step per division:					var rad:Number = 2 * Math.PI / divisions;					this.addPoint(hub);					// make points on outer layer, add connection to each from hub ("spokes")					for (var i = 0; i < divisions; i++)					{						var newPoint:PointMass = new PointMass(1,new Point(center.x + radius * Math.cos(i * rad),center.y + radius * Math.sin(i * rad)));						var spoke:Connection = new Connection(hub,newPoint,radius,0.03);						this.addLink(spoke);					}// now that all spokes are created, add "skin" (connection between outer points)					//uses wrapping function to close ring (where allPoints[divisions] connects to allPoints[1])					for (i = 1; i < divisions+1; i++)					{						// connection to one point away						var skin1:Connection = new Connection(this.allPoints[i],this.allPoints[wrap(i+1,divisions+1)],(rad*radius),0.03);						this.addLink(skin1);						// connection to two away						var skin2:Connection = new Connection(this.allPoints[i],this.allPoints[wrap(i+2,divisions+1)],(2*rad*radius),0.03);						this.addLink(skin2);					}					// connect across the middle. Loop over HALF the points					//  because each has a pair - once one is connected so 					//is the other by virtue of the action/reaction nature					//of each connection					// this connection is weaker because it more directly affects 					//the rigidity of the blob than any other connection					for (i = 1; i < (divisions+1)/2; i++)					{						var longSpoke:Connection = new Connection(this.allPoints[i],this.allPoints[wrap(i + divisions / 2,divisions + 1)],2 * radius,0.02);						this.addLink(longSpoke);					}					break;			}		}		// wrap - a helper function for iterating the exterior points of the blob.		// blob is circular, with 0th index not included in outer ring (0th is center)		//this wrapping function wraps forward (only for values getting larger).		private function wrap(n, max)		{			if (n < max)			{				return n;			}			else			{				// if at max, return 1.				// if 1 greater than max, return 2,				// etc...				// ASSUMES that (n - max + 1) is LESS THAN max				return (n - max) + 1;			}		}		// override parent disp by allowing fill		public function dispFill(dispClip:MovieClip, c:uint = 0x000000):void		{			dispClip.graphics.beginFill(c);			var num_points = this.allPoints.length;			// Filling with curveTo, this function makes a continuous skin around the blob. looks more blob-y.			// 			for (var i = 1; i < num_points; i++)			{				var pointA:Point = allPoints[wrap(i, num_points)].pos;				var pointB:Point = allPoints[wrap(i + 1, num_points)].pos;				var pointC:Point = allPoints[wrap(i + 2, num_points)].pos;				var avgAB:Point = Point.interpolate(pointA,pointB,0.5);				var avgBC:Point = Point.interpolate(pointB,pointC,0.5);				if(i == 1)					dispClip.graphics.moveTo(avgAB.x, avgAB.y);				dispClip.graphics.curveTo(pointB.x, pointB.y, avgBC.x, avgBC.y);			}			dispClip.graphics.endFill();		}	}}