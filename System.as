// System.as// written by Richard Lange// A system is a bunch of pointmasses and connections.// functions provided to add Points individually, add//	Connections (addLink), calculate next state (update),//	and force the system to exist in a box (contain)package  {	import flash.geom.Point;	import flash.display.MovieClip;	import flash.geom.Vector3D;	public class System {		public var allPoints:Array		public var allConnections:Array;				public function System() {			allPoints = new Array();			allConnections = new Array();		}				public function addPoint(p:PointMass):void {			allPoints.push(p);		}				public function addLink(c:Connection):void {			//first add points if they aren't already in the system			var points = c.getPoints();			if(allPoints.indexOf(points[0]) < 0) addPoint(points[0]);			if(allPoints.indexOf(points[1]) < 0) addPoint(points[1]);			//now add the connection			allConnections.push(c);		}				public function updateAll():void {			// Important!			// to avoid weird glitchy/twitchy movements of points,			//	all forces are summed using the spring() function			//	on all connections. THEN the points are moved.			//	This function should be called every frame.			for (var i = 0; i < allConnections.length; i++) {				allConnections[i].spring();			}			for (i = 0; i < allPoints.length; i++) {				allPoints[i].flush();			}		}				public function drift(force:Vector3D):void {			// add a force to all points. Useful for simulating			//	things like gravity, wind, or controlling with keyboard			for (var i = 0; i < allPoints.length; i++){				allPoints[i].addForce(force);			}		}				public function disp(dispClip:MovieClip, c:uint = 0x000000):void {			// display a system by displaying all connections.			var also_draw_points:Boolean = true;			dispClip.graphics.clear();			for (var i = 0; i < allConnections.length; i++) {				allConnections[i].disp(dispClip, also_draw_points, c)			}		}				public function contain(minX:Number, minY:Number, maxX:Number, maxY:Number, wallFriction:Number = 0){			// this function keeps a system within a box (contains it). Suggest using stage boundaries for simple tests.			// 	it does this by iterating over all point-masses. if a point-mass is 			//	outside of the given boundaries, its position is set to the boundary, 			//	it's velocity is set to zero, and it is given friction along the			//	boundary/"wall" proportional to its velocity (so.. wall 'viscosity' I guess?)						// providing some (>0) wall-friction is what gives the impression of 'rolling' to the blobs.						if(wallFriction < 0)				wallFriction = 0;						for (var i = 0; i < allPoints.length; i++){				var pt:PointMass = allPoints[i];				if(pt.pos.x < minX) {					pt.pos.x = minX;					pt.vel.x = 0;					pt.addForce(new Vector3D(0,-pt.vel.y*wallFriction));				}				else if(pt.pos.x > maxX) {					pt.pos.x = maxX;					pt.vel.x = 0;					pt.addForce(new Vector3D(0,-pt.vel.y*wallFriction));				}				if(pt.pos.y < minY) {					pt.pos.y = minX;					pt.vel.y = 0;					pt.addForce(new Vector3D(-pt.vel.x*wallFriction,0));				}				else if(pt.pos.y > maxY){					pt.pos.y = maxY;					pt.vel.y = 0;					pt.addForce(new Vector3D(-pt.vel.x*wallFriction,0));				}			}		}	}}